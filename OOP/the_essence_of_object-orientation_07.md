

# 함께 모으기

### 개념 관점

- 설계는 도메인 안에 존재하는 개념과 개념들 사이의 관계를 표현
- 도메인이란 사용자들이 관심을 가지고 있는 특정 분야나 주제
- 실제 도메인의 규칙과 제약을 최대한 유사하게 반영하는 것이 핵심

### 명세 관점

- 사용자의 영역인 도메인을 벗어나 개발자의 영역인 소프트웨어로 초점이 옮겨짐
- 도메인이 아니라 소프트웨어 안의 객체들의 책임에 초점 (즉 인터페이스를 바라보게 된다.)
- 인터페이스와 구현을 분리하는 것은 훌륭한 객체지향 설계를 낳는 기본적인 원칙
- 구현이 아니라 인터페이스에 대해 프로그래밍 하라

### 구현 관점

- 실제 작업을 수행하는 코드와 연관
- 객체들이 책임을 수행하는 데 필요한 동작하는 코드를 작성
- 객체의 책임을 ‘어떻게’ 수행할 것인가에 초점을 맞추며 인터페이스를 구현하는데 필요한 속성과 메서드를 클래스에 추가

개념 관점, 명세 관점, 구현 관점의 순서대로 개발하라는 의미로 들릴 수 있지만 동일한 클래스를 세 가지 다른 방향에서 바라보는 것을 의미한다.

클래스가 은유하는 개념은 도메인 관점을 반영한다. 클래스의 공용 인터페이스는 명세 관점을 반영한다. 클래스의 속성과 메서드는 구현 관점을 반영한다.

클래스는  개념, 인터페이스, 구현을 함께 드러내면서 세 가지 관점을 쉽게 식별할 수 있도록 깔끔하게 분리해야 한다.

## 부록A. 추상화 기법

추상화는 도메인의 복잡성을 단순화하고 직관적인 멘탈 모델을 만드는 데 사용할 수 있는 가장 기본적인 인지 수단이다. 다음은 중요한 추상화 기법의 종류를 나타낸 것이다.

- 분류와 인스턴스화 : 분류는 객체의 구체적인 세부 사항을 숨기고 인스턴스 간에 공유하는 공통적인 특성을 기반으로 범주를 형성하는 과정이다. 분류의 역은 범주로부터 객체를 생성하는 인스턴스화 과정이다.
- 일반화와 특수화 : 일반화는 범주 사이의 차이를 숨기고 범주 간에 공유하는 공통적인 특성을 강조한다. 일반화의 역을 트굿화라고 한다.
- 집합과 분해 : 집합은 부분과 관련된 세부 사항을 숨기고 부분을 사용해서 전체를 형성하는 과정을 가리킨다. 집합의 반대 과정은 전체를 부분으로 분리하는 분해 과정이다.

### 외연과 집합

타입의 외연은 타입에 속하는 객체들의 집합으로 표현한다. 객체들은 동시에 서로 다른 집합에 포함될 수도 있다.

한 객체가 한 시점에 하나의 타입에만 속하는 것을 단일 분류라고 하고, 한 객체가 한 시점에 여러 타입에 속할 경우 이를 다중 분류라고 한다.

대부분의 객체지향 프로그래밍 언어들은 단일 분류만을 지원한다. 한 객체는 오직 한 클래스의 인스턴스여야만 하며 동시에 두 개의 클래스의 인스턴스일 수는 없다.

이 관점에서 **다중 분류를 다중 상속과 혼동해서는 안 된다.** 다중 상속은 하나의 타입이 다수의 슈퍼타입을 가질 수 있도록 허용하지만 타입 정의를 생략할 수는 없다.

반면 다중 분류는 특정한 타입을 정의하지 않고도 하나의 객체가 서로 다른 타입의 인스턴스가 되도록 허용한다.

객체를 특정한 타입으로 분류하면 해당 객체는 타입의 집합에 포함된다. 객체가 한 집합에서 다른 집합의 원소로 타입을 변경할 수 있는 경우 이를 동적 분류라고 한다. 객체가 자신의 타입을 변경할 수 없는 경우 이를 정적 분류라고 한다.

대부분의 언어는 인스턴스를 생성한 후 클래스를 변경할 수 있는 방법을 제공하지 않는다. 즉, 객체의 타입을 변경할 수 없으므로 우리가 사용하는 대부분의 언어는 정적 분류만 허용하며 동적 분류를 구현할 수 있는 방법을 제공하지 않는다.

다중 분류와 동적 분류는 개념적인 관점에서 도메인을 분석하는 데는 유용하지만 객체지향 언어의 제약으로 이를 구현으로 옮기기는 쉽지 않다. 다중 분류와 동적 분류 관점에서 도메인 모델의 초안을 만든 후 실제 구현에 적합하도록 단일 분류와 정적 분류 방식으로 객체들의 범주를 재조정하는 편이 분석과 구현 간의 차이를 메울 수 있는 현실적인 방법이다.

### 상속

프로그래밍 언어를 이용해 일반화와 특수화 관계를 구현하는 가장 일반적인 방법은 클래스 간의 상속을 이용하는 것이다. 그러나 모든 상속 관계가 일반화 관계인 것은 아니다.

일반화의 원칙은 한 타입이 다른 타입의 서브타입이 되기 위해서는 슈퍼타입에 순응해야 한다는 것이다. 순응에는 구조적인 순응과 행위적인 순응 두 가지 종류가 있다. 두 가지 모두 서브타입의 슈퍼타입에 대한 대체 가능성을 의미한다. 

**구조적인 순응**

구조적인 순응은 타입의 내연과 관련된 100% 규칙을 의미한다. 즉, 서브타입은 슈퍼타입이 가지고 있는 속성과 연관관계 면에서 100% 일치해야 한다. 예를 들어 Person이 name이라는 속성을 가진다면 Person의 서브타입인 Employee 역시 name이라는 속성을 가질 것이라고 기대할 수 있다. 따라서 Employee는 Person에 대해 구조적으로 순응하며 Person을 대체할 수 있다.

**행위적인 순응**

행위적인 순응은 타입의 행위에 관한 것이며 행위적인 순응을 흔히 리스코프 치환 원칙이라고 한다. Person이 getAge()라는 메시지에 대한 응답으로 나이를 반환한다면 서브타입인 Employee 역시 getAge()라는 메시지에 대해 나이를 반환해야 한다. 

한 클래스가 다른 클래스를 상속한다면 상속하는 타입은 부모 클래스의 데이터와 메서드를 사용하고, 수정하고, 확장할 수 있다. 어떤 프로그래밍 언어도 상속이 대체 가능성을 만든다는 것을 보장하지 않는다.

상속은 서브타이핑과 서브클래싱의 두 가지 용도로 사용될 수 있다. 서브클래스가 슈퍼클래스를 대체할 수 있는 경우 이를 서브타이핑이라고 한다. 그렇지 않다면 이를 서브클래싱이라고 한다. 

서브타이핑은 설계의 유연성이 목표인 반면 서브클래싱은 코드의 중복 제거와 재사용이 목적이다. 흔히 서브타이핑을 **인터페이스 상속**이라고 하고, 서브클래싱을 **구현 상속**이라고 한다.

요약하면 일반화를 위한 서브타이핑은 서브타입과 슈퍼타입 간의 구조적 또는 행위적 순응 관계를 의미하며 대체 가능성을 내포한다. 상속은 서브타이핑을 프로그래밍 언어적으로 구현하는 데 사용될 수 있지만 모든 상속이 서브타이핑인 것은 아니다. 서브클래스가 슈퍼클래스를 대체할 수 없고 단지 코드만 공유하고 있다면 서브클래싱이라고 한다. 가능한 모든 상속 관계가 서브타이핑의 대체 가능성을 준수하도록 설계해야 코드의 유연성이 높아지고 재사용성을 높일 수 있다.

여러 클래스로 구성된 상속 계층에서 수신된 메시지를 이해하는 기본적인 방법은 클래스 간의 위임(delegation)을 사용하는 것이다. 어떤 객체의 클래스가 메시지를 이해할 수 없다면 메시지를 클래스의 부모 클래스로 위임한다. 만약 부모 클래스도 메시지를 이해할 수 없다면 자신의 부모 클래스로 다시 위임한다. **클래스 간의 위임 사슬은 메시지를 처리하거나 최상위 부모 클래스에 위임 될 때까지 계속된다**.